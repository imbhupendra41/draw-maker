<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="assets/fabric/fabric.js"></script>
    <link rel="stylesheet" href="assets/font-awesome/css/all.min.css">
    <link rel="stylesheet" href="draw-maker.css">
    <script src="draw-maker.js"></script>
</head>

<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/3.6.2/fabric.min.js"></script>

    <div style="display: inline-block; border: 1px solid gray">
        <canvas id="canvas"></canvas>
    </div>

    <input type="radio" name="maker" onclick="return onMakerClick(event, PencilBrushMaker)" />
    <label>PencilBrush</label><br />
    <input type="radio" name="maker" onclick="return onMakerClick(event, TextBoxMaker)" />
    <label>TextBox</label><br />
    <input type="radio" name="maker" onclick="return onMakerClick(event, LineMaker)" />
    <label>Line</label><br />
    <input type="radio" name="maker" onclick="return onMakerClick(event, ArrowMaker)" />
    <label>Arrow</label><br />
    <input type="radio" name="maker" onclick="return onMakerClick(event, DoubleArrowMaker)" />
    <label>DoubleArrow</label><br />
    <input type="radio" name="maker" onclick="return onMakerClick(event, RectMaker)" />
    <label>Rect</label><br />
    <input type="radio" name="maker" onclick="return onMakerClick(event, CircleMaker)" />
    <label>Circle</label><br />
    <input type="radio" name="maker" onclick="return onMakerClick(event, TriangleMaker)" />
    <label>Triangle</label><br />

    <button onclick="onZoomInClick(event)">Zoom In</button>
    <button onclick="onZoomOutClick(event)">Zoom Out</button>

    <script>
        function onZoomInClick(event) {
            let zoom = Math.min(canvas.getZoom() * dm.ZOOM_FACTOR, 5);
            //canvas.setZoom(zoom);
            let center = canvas.getCenter();
            canvas.zoomToPoint(new fabric.Point(center.left, center.top), zoom);
        }

        function onZoomOutClick(event) {
            let zoom = Math.max(canvas.getZoom() / dm.ZOOM_FACTOR, 1);
            //canvas.setZoom(zoom);
            let center = canvas.getCenter();
            canvas.zoomToPoint(new fabric.Point(center.left, center.top), zoom);
        }

        function onMakerClick(event, maker) {
            let selectedAttr = "data-dm-selected";
            let selectedValue = false;
            let success = false;
            if (event.target.getAttribute(selectedAttr) != 'true') {
                success = dm.select(maker);
                selectedValue = success;
            }
            if (event.target.getAttribute(selectedAttr) == 'true') {
                success = dm.deselect(maker);
                selectedValue = !success;
            }
            if (success) {
                document.querySelectorAll('input[type=radio][name=maker]').forEach(function (el) {
                    el.setAttribute(selectedAttr, false)
                });
                event.target.checked = selectedValue;
                event.target.setAttribute(selectedAttr, selectedValue);
            }
            return success;
        };

        var canvas = new fabric.Canvas("canvas", {
            width: 200,
            height: 200,
        });

        function RectMaker(dm) {

            this.dm = dm;
            this.shape = null;
            this.attached = false;
            this.settings = ['fillColor', 'lineColor', 'lineWidth'];

            this.start = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                this.shape = new fabric.Rect({
                    left: pointer.x,
                    top: pointer.y,
                    width: 1,
                    height: 1,
                    fill: this.dm.fillColor,
                    stroke: this.dm.lineColor,
                    strokeWidth: this.dm.lineWidth,
                    evented: false,
                });
                this.attached = false;
            };

            this.update = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                let width = pointer.x - this.shape.get('left');
                let height = pointer.y - this.shape.get('top');
                this.shape.set('width', width);
                this.shape.set('height', height);
                if (!this.attached) {
                    canvas.add(this.shape);
                    this.attached = true;
                }
                canvas.requestRenderAll();
            };

            this.stop = function (canvas, options) {
            };

            this.select = function (canvas) {
            };

            this.deselect = function (canvas) {
            };

        };

        function CircleMaker(dm) {

            this.dm = dm;
            this.shape = null;
            this.startLeft = 0;
            this.startTop = 0;
            this.attached = false;
            this.settings = ['fillColor', 'lineColor', 'lineWidth'];

            this.start = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                this.startLeft = pointer.x;
                this.startTop = pointer.y;
                this.shape = new fabric.Circle({
                    originX: 'center',
                    originY: 'center',
                    left: this.startLeft,
                    top: this.startTop,
                    radius: 1,
                    fill: this.dm.fillColor,
                    stroke: this.dm.lineColor,
                    strokeWidth: this.dm.lineWidth,
                    evented: false,
                });
                this.attached = false;
            };

            this.update = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                let width = (pointer.x - this.startLeft) / 2;
                let height = (pointer.y - this.startTop) / 2;
                let centerX = pointer.x - width;
                let centerY = pointer.y - height;
                let radius = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
                this.shape.set('left', centerX);
                this.shape.set('top', centerY);
                this.shape.set('radius', radius);
                if (!this.attached) {
                    canvas.add(this.shape);
                    this.attached = true;
                }
                canvas.requestRenderAll();
            };

            this.stop = function (canvas, options) {
            };

            this.select = function (canvas) {
            };

            this.deselect = function (canvas) {
            };

        };

        function TriangleMaker(dm) {

            this.dm = dm;
            this.shape = null;
            this.attached = false;
            this.settings = ['fillColor', 'lineColor', 'lineWidth'];

            this.start = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                this.shape = new fabric.Triangle({
                    left: pointer.x,
                    top: pointer.y,
                    width: 1,
                    height: 1,
                    fill: this.dm.fillColor,
                    stroke: this.dm.lineColor,
                    strokeWidth: this.dm.lineWidth,
                    evented: false,
                });
                this.attached = false;
            };

            this.update = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                let width = pointer.x - this.shape.get('left');
                let height = pointer.y - this.shape.get('top');
                this.shape.set('width', width);
                this.shape.set('height', height);
                if (!this.attached) {
                    canvas.add(this.shape);
                    this.attached = true;
                }
                canvas.requestRenderAll();
            };

            this.stop = function (canvas, options) {
            };

            this.select = function (canvas) {
            };

            this.deselect = function (canvas) {
            };

        };

        function LineMaker(dm) {

            this.dm = dm;
            this.shape = null;
            this.attached = false;
            this.settings = ['lineColor', 'lineWidth'];

            this.start = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                this.shape = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
                    originX: 'center',
                    originY: 'center',
                    fill: null,
                    stroke: this.dm.getVisibleColor(this.dm.lineColor),
                    strokeWidth: this.dm.lineWidth,
                    evented: false,
                });
                this.attached = false;
            };

            this.update = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                this.shape.set('x2', pointer.x);
                this.shape.set('y2', pointer.y);
                if (!this.attached) {
                    canvas.add(this.shape);
                    this.attached = true;
                }
                canvas.requestRenderAll();
            };

            this.stop = function (canvas, options) {
            };

            this.select = function (canvas) {
            };

            this.deselect = function (canvas) {
            };

        };

        function ArrowMaker(dm) {

            this.dm = dm;
            this.shapes = null;
            this.attached = false;
            this.settings = ['lineColor', 'lineWidth'];

            this._headSize = function (lineWidth) {
                let sizeFactor = 5;
                return sizeFactor + (sizeFactor / 2.0 * lineWidth);
            };

            this._arrowAngle = function (x1, y1, x2, y2) {
                return (Math.atan2((y2 - y1), (x2 - x1)) * (180 / Math.PI)) + 90;
            };

            this.start = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                let lineColor = this.dm.getVisibleColor(this.dm.lineColor);
                let lineShape = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
                    originX: 'center',
                    originY: 'center',
                    fill: lineColor,
                    stroke: lineColor,
                    strokeWidth: this.dm.lineWidth,
                    selectable: false,
                    evented: false,
                });
                let headSize = this._headSize(this.dm.lineWidth);
                let arrowAngle = this._arrowAngle(pointer.x, pointer.y, pointer.x, pointer.y);
                let triangleShape = new fabric.Triangle({
                    originX: 'center',
                    originY: 'top',
                    left: pointer.x,
                    top: pointer.y,
                    angle: arrowAngle,
                    width: headSize,
                    height: headSize,
                    fill: lineColor,
                    stroke: lineColor,
                    strokeWidth: this.dm.lineWidth,
                    selectable: false,
                    evented: false,
                });
                this.shape = null;
                this.shapes = [lineShape, triangleShape];
                this.attached = false;
            };

            this.update = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                let lineShape = this.shapes[0];
                lineShape.set('x2', pointer.x);
                lineShape.set('y2', pointer.y);
                let x1 = lineShape.get('x1');
                let y1 = lineShape.get('y1');
                let arrowAngle = this._arrowAngle(x1, y1, pointer.x, pointer.y);
                let triangleShape = this.shapes[1];
                triangleShape.set('left', pointer.x);
                triangleShape.set('top', pointer.y);
                triangleShape.set('angle', arrowAngle);
                if (!this.attached) {
                    canvas.add(...this.shapes);
                    this.attached = true;
                }
                canvas.requestRenderAll();
            };

            this.stop = function (canvas, options) {
                if (this.attached) {
                    let group = new fabric.Group(this.shapes, {
                        evented: false,
                    });
                    canvas.add(group);
                }
                canvas.requestRenderAll();
            };

            this.select = function (canvas) {
            };

            this.deselect = function (canvas) {
            };

        };

        function DoubleArrowMaker(dm) {

            this.dm = dm;
            this.shapes = null;
            this.attached = false;
            this.settings = ['lineColor', 'lineWidth'];

            this._headSize = function (lineWidth) {
                let sizeFactor = 5;
                return sizeFactor + (sizeFactor / 2.0 * lineWidth);
            };

            this._arrowAngle = function (x1, y1, x2, y2) {
                return (Math.atan2((y2 - y1), (x2 - x1)) * (180 / Math.PI)) + 90;
            };

            this.start = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                let lineColor = this.dm.getVisibleColor(this.dm.lineColor);
                let lineShape = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
                    originX: 'center',
                    originY: 'center',
                    fill: lineColor,
                    stroke: lineColor,
                    strokeWidth: this.dm.lineWidth,
                    selectable: false,
                    evented: false,
                });
                let headSize = this._headSize(this.dm.lineWidth);
                let toArrowAngle = this._arrowAngle(pointer.x, pointer.y, pointer.x, pointer.y);
                let toTriangleShape = new fabric.Triangle({
                    originX: 'center',
                    originY: 'top',
                    left: pointer.x,
                    top: pointer.y,
                    angle: toArrowAngle,
                    width: headSize,
                    height: headSize,
                    fill: lineColor,
                    stroke: lineColor,
                    strokeWidth: this.dm.lineWidth,
                    selectable: false,
                    evented: false,
                });
                let fromArrowAngle = toArrowAngle + 180;
                let fromTriangleShape = new fabric.Triangle({
                    originX: 'center',
                    originY: 'top',
                    left: pointer.x,
                    top: pointer.y,
                    angle: fromArrowAngle,
                    width: headSize,
                    height: headSize,
                    fill: lineColor,
                    stroke: lineColor,
                    strokeWidth: this.dm.lineWidth,
                    selectable: false,
                    evented: false,
                });
                this.shape = null;
                this.shapes = [lineShape, toTriangleShape, fromTriangleShape];
                this.attached = false;
            };

            this.update = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                let lineShape = this.shapes[0];
                lineShape.set('x2', pointer.x);
                lineShape.set('y2', pointer.y);
                let x1 = lineShape.get('x1');
                let y1 = lineShape.get('y1');
                let toArrowAngle = this._arrowAngle(x1, y1, pointer.x, pointer.y);
                let toTriangleShape = this.shapes[1];
                toTriangleShape.set('left', pointer.x);
                toTriangleShape.set('top', pointer.y);
                toTriangleShape.set('angle', toArrowAngle);
                let fromArrowAngle = toArrowAngle + 180;
                let fromTriangleShape = this.shapes[2];
                fromTriangleShape.set('angle', fromArrowAngle);
                if (!this.attached) {
                    canvas.add(...this.shapes);
                    this.attached = true;
                }
                canvas.requestRenderAll();
            };

            this.stop = function (canvas, options) {
                if (this.attached) {
                    let group = new fabric.Group(this.shapes, {
                        evented: false,
                    });
                    canvas.add(group);
                }
                canvas.requestRenderAll();
            };

            this.select = function (canvas) {
            };

            this.deselect = function (canvas) {
            };

        };

        function TextBoxMaker(dm) {

            this.dm = dm;
            this.shape = null;
            this.settings = ['lineColor'];

            this.start = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                this.shape = new fabric.Textbox('Text...', {
                    originX: 'center',
                    originY: 'center',
                    left: pointer.x,
                    top: pointer.y,
                    textAlign: 'left',
                    lineHeight: 1,
                    fontSize: 20,
                    fontWeight: 'normal',
                    fontStyle: 'normal',
                    fill: this.dm.getVisibleColor(this.dm.lineColor),
                    stroke: null,
                    strokeWidth: 0,
                    evented: false,
                });
                canvas.add(this.shape);
                canvas.requestRenderAll();
            };

            this.update = function (canvas, options) {
                let pointer = canvas.getPointer(options.e, true);
                this.shape.set('left', pointer.x);
                this.shape.set('top', pointer.y);
                canvas.requestRenderAll();
            };

            this.stop = function (canvas, options) {
            };

            this.select = function (canvas) {
            };

            this.deselect = function (canvas) {
            };

        };

        function PencilBrushMaker(dm) {

            this.dm = dm;
            this.settings = ['lineColor', 'lineWidth'];

            this.start = function (canvas, options) {
            };

            this.update = function (canvas, options) {
            };

            this.stop = function (canvas, options) {
            };

            this.select = function (canvas) {
                let pencil = new fabric.PencilBrush(canvas);
                pencil.color = this.dm.getVisibleColor(this.dm.lineColor);
                pencil.width = this.dm.lineWidth;
                canvas.freeDrawingBrush = pencil;
                canvas.isDrawingMode = true;
            };

            this.deselect = function (canvas) {
                canvas.isDrawingMode = false;
            };

        };

        function DrawMaker() {

            /*
            - No Maker, disparar evento ao fazer Start/Stop, assim os botões específicos da interface ficam houvindo.
            - Ex: drawmaker.on/off('draw:start/stop', function).
            - Colocar no  mouse um texto quando objeto/maker selecionado, para todos.
            */

            this.DEFAULT_COLOR = 'rgb(255,0,0)';
            this.DEFAULT_TRANSPARENCY = null;
            this.ZOOM_FACTOR = 1.3;

            this.selected = null;
            this.making = null;

            this.fillColor = this.DEFAULT_TRANSPARENCY;
            this.lineColor = this.DEFAULT_COLOR;
            this.lineWidth = 2;

            this.getVisibleColor = function (color) {
                if (!color || color == this.DEFAULT_TRANSPARENCY)
                    color = this.DEFAULT_COLOR;
                return color;
            };

            this.getSelectableObjects = function () {
                let objs = canvas.getObjects();
                let groups = canvas.getObjects('group');
                groups.forEach(function (group) {
                    objs = objs.filter(function (obj) {
                        return obj.selectable && !group.getObjects().includes(obj);
                    });
                });
                return objs;
            };

            this.dummyObjectSelection = function () {
                // For unknown reasons, some individual object selections only works after a grouping selection.
                // But if grouping selection selects objects of a group, it generates some invalid copies.
                let objs = this.getSelectableObjects();
                canvas.discardActiveObject();
                canvas.setActiveObject(new fabric.ActiveSelection(objs));
                canvas.discardActiveObject();
            };

            this.enableObjectSelection = function () {
                this.dummyObjectSelection();
                this.getSelectableObjects().forEach(function (obj) {
                    obj.set('evented', true);
                });
                canvas.set('selection', true);
                canvas.requestRenderAll();
            };

            this.disableObjectSelection = function () {
                canvas.discardActiveObject();
                this.getSelectableObjects().forEach(function (obj) {
                    obj.set('evented', false);
                });
                canvas.set('selection', false);
                canvas.requestRenderAll();
            };

            this.select = function (maker) {
                if (dm.making) {
                    return false;
                }
                if (this.selected) {
                    this.selected.deselect(canvas);
                }
                this.selected = new maker(this);
                this.selected.select(canvas);
                this.disableObjectSelection();
                return true;
            };

            this.deselect = function (maker) {
                if (dm.making) {
                    return false;
                }
                if (this.selected) {
                    this.selected.deselect(canvas);
                    this.selected = null;
                }
                this.enableObjectSelection();
                return true;
            };
        };

        var dm = new DrawMaker();

        canvas.on('mouse:down', function (options) {
            if (dm.selected && !dm.making) {
                dm.making = dm.selected;
                dm.making.start(canvas, options);
            }
        });

        canvas.on('mouse:move', function (options) {
            if (dm.making) {
                dm.making.update(canvas, options);
            }
        });

        canvas.on('mouse:up', function (options) {
            if (dm.making) {
                dm.making.stop(canvas, options);
                dm.making = null;
            }
        });

    </script>
</body>

</html>